{"version":3,"sources":["../../../source/SearchIndex/TfIdfSearchIndex.js"],"names":["TfIdfSearchIndex","uidFieldName","_uidFieldName","_tokenToIdfCache","_tokenMap","token","uid","doc","tokenMap","tokenDatum","$numDocumentOccurrences","$totalNumOccurrences","$uidMap","uidMap","$document","$numTokenOccurrences","tokens","corpus","uidToDocumentMap","i","numTokens","length","tokenMetadata","keys","Object","j","numKeys","documents","push","calculateTfIdf","_createCalculateTfIdf","sort","documentA","documentB","tokenToIdfCache","calculateIdf","numDocumentsWithToken","Math","log","_createCalculateIdf","document","score","inverseDocumentFrequency","Infinity","Array","termFrequency"],"mappings":"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","file":"TfIdfSearchIndex.js","sourcesContent":["// @flow\nimport getNestedFieldValue from '../getNestedFieldValue';\n\nimport type { ISearchIndex } from './SearchIndex';\n\ntype ITfIdfTokenMap = {\n  [token : string] : ITfIdfTokenMetadata;\n};\n\ntype ITfIdfUidMap = {\n  [uid : string] : ITfIdfUidMetadata;\n};\n\ntype ITfIdfTokenMetadata = {\n  $numDocumentOccurrences : number;\n  $totalNumOccurrences : number;\n  $uidMap : ITfIdfUidMap;\n};\n\ntype ITfIdfUidMetadata = {\n  $document : Object;\n  $numTokenOccurrences : number;\n};\n\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\nexport class TfIdfSearchIndex implements ISearchIndex {\n  _uidFieldName : string | Array<string>;\n  _tokenToIdfCache : {[token : string] : number};\n  _tokenMap : ITfIdfTokenMap;\n\n  constructor(uidFieldName : string | Array<string>) {\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n\n  /**\n   * @inheritDocs\n   */\n  indexDocument(token : string, uid : string, doc : Object) : void {\n    this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n    var tokenMap = this._tokenMap;\n    var tokenDatum;\n\n    if (typeof tokenMap[token] !== 'object') {\n      tokenMap[token] = tokenDatum = {\n        $numDocumentOccurrences: 0,\n        $totalNumOccurrences: 1,\n        $uidMap: {},\n      };\n    } else {\n      tokenDatum = tokenMap[token];\n      tokenDatum.$totalNumOccurrences++;\n    }\n\n    var uidMap = tokenDatum.$uidMap;\n\n    if (typeof uidMap[uid] !== 'object') {\n      tokenDatum.$numDocumentOccurrences++;\n      uidMap[uid] = {\n        $document: doc,\n        $numTokenOccurrences: 1\n      };\n    } else {\n      uidMap[uid].$numTokenOccurrences++;\n    }\n  }\n\n  /**\n   * @inheritDocs\n   */\n  search(tokens : Array<string>, corpus : Array<Object>) : Array<Object> {\n    var uidToDocumentMap : {[uid : string] : Object} = {};\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var tokenMetadata = this._tokenMap[token];\n\n      // Short circuit if no matches were found for any given token.\n      if (!tokenMetadata) {\n        return [];\n      }\n\n      if (i === 0) {\n        var keys = Object.keys(tokenMetadata.$uidMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n        }\n      } else {\n        var keys = Object.keys(uidToDocumentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          if (typeof tokenMetadata.$uidMap[uid] !== 'object') {\n            delete uidToDocumentMap[uid];\n          }\n        }\n      }\n    }\n\n    var documents = [];\n\n    for (var uid in uidToDocumentMap) {\n      documents.push(uidToDocumentMap[uid]);\n    }\n\n    var calculateTfIdf = this._createCalculateTfIdf();\n\n    // Return documents sorted by TF-IDF\n    return documents.sort((documentA, documentB) =>\n      calculateTfIdf(tokens, documentB, corpus) -\n      calculateTfIdf(tokens, documentA, corpus)\n    );\n  }\n\n  _createCalculateIdf () : Function {\n    var tokenMap = this._tokenMap;\n    var tokenToIdfCache = this._tokenToIdfCache;\n\n    return function calculateIdf(token : string, documents : Array<Object>) : number {\n      if (!tokenToIdfCache[token]) {\n        var numDocumentsWithToken:number = typeof tokenMap[token] !== 'undefined'\n          ? tokenMap[token].$numDocumentOccurrences\n          : 0;\n\n        tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n      }\n\n      return tokenToIdfCache[token];\n    }\n  }\n\n  _createCalculateTfIdf () : Function {\n    var tokenMap = this._tokenMap;\n    var uidFieldName = this._uidFieldName;\n    var calculateIdf = this._createCalculateIdf();\n\n    return function calculateTfIdf(tokens : Array<string>, document : Object, documents : Array<Object>) : number {\n      var score:number = 0;\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n        var token:string = tokens[i];\n\n        var inverseDocumentFrequency:number = calculateIdf(token, documents);\n\n        if (inverseDocumentFrequency === Infinity) {\n          inverseDocumentFrequency = 0;\n        }\n\n        var uid:any;\n        if (uidFieldName instanceof Array) {\n          uid = document && getNestedFieldValue(document, uidFieldName);\n        } else {\n          uid = document && document[uidFieldName];\n        }\n\n        var termFrequency:number =\n          typeof tokenMap[token] !== 'undefined' &&\n          typeof tokenMap[token].$uidMap[uid] !== 'undefined'\n            ? tokenMap[token].$uidMap[uid].$numTokenOccurrences\n            : 0;\n\n        score += termFrequency * inverseDocumentFrequency;\n      }\n\n      return score;\n    }\n  }\n};\n"]}